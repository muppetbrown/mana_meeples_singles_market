var c=Object.defineProperty;var u=(i,t,e)=>t in i?c(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var a=(i,t,e)=>u(i,typeof t!="symbol"?t+"":t,e);class o{constructor(){a(this,"activeRequests");a(this,"maxConcurrent");a(this,"minDelay");a(this,"requestHistory");this.activeRequests=new Map,this.requestHistory=new Map,this.minDelay=800,this.maxConcurrent=1}getEndpointKey(t){try{return new URL(t).pathname}catch{return t}}async waitForDelay(t){const e=this.requestHistory.get(t);if(e){const s=Date.now()-e;if(s<this.minDelay){const r=this.minDelay-s;await new Promise(n=>setTimeout(n,r))}}}async waitForConcurrency(t){for(;!((this.activeRequests.get(t)||0)<this.maxConcurrent);)await new Promise(s=>setTimeout(s,100))}startRequest(t){const e=this.activeRequests.get(t)||0;this.activeRequests.set(t,e+1),this.requestHistory.set(t,Date.now())}endRequest(t){const e=this.activeRequests.get(t)||1;e<=1?this.activeRequests.delete(t):this.activeRequests.set(t,e-1)}async fetch(t,e={}){const s=this.getEndpointKey(t);await this.waitForDelay(s),await this.waitForConcurrency(s),this.startRequest(s);try{return await fetch(t,e)}finally{this.endRequest(s)}}reset(){this.activeRequests.clear(),this.requestHistory.clear()}}const q=new o;export{o as RequestThrottler,q as default};
